<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8">
    <title>Go Programming Language Website</title>
</head>

<body>
    <header id="main">
        <h1 id="banner">Go, GoLang</h1>
        <h2 id="banner">Description and History</h2>
    </header>
    <nav>
        <ul id="nav">
            <li id="navItem"><a id="navLink" href="index.html">Description and History</a></li>
            <li id="navItem"><a id="navLink" href="pg1.html">Links</a></li>
            <li id="navItem"><a id="navLink" href="pg2.html">Translators and Installation</a></li>
            <li id="navItem"><a id="navLink" href="pg3.html">Simple Examples</a></li>
            <li id="navItem"><a id="navLink" href="pg4.html">Complex Examples</a></li>
            <li id="navItem"><a id="navLink" href="pg5.html">Language Comparison</a></li>
        </ul>
    </nav>
    <p>  
    Go!!! Also referred to as GoLang. Created at Google in 2009 by Robert Griesemer, Rob Pike, and Ken Thompson. Go is compiled and statically typed. Go is sort of modeled after C or Algol, but it includes garbage collection (thank god), limited structural typing (type inheritance), memory safety features that prevent bugs and vulnerabilities from accessing memory (buffer overflow, dangling pointer, essentially tools to ensure you use pointers correctly because Go uses pointers), and features which help to support concurrent programming. Best yet, is that the Go langauge compiler and its expansive library of tools are available open source (yes, that means for free...)!!!
    </p>  
    <p>
    Syntax and Type:
    As previously mentioned, it looks a lot like C. Go is based off of "the best parts" of C++, Java, and Python. Improvements made to improve language readability and simplicity, as well as memory safety. Variable declaration and initialization done through type inference. This mostly means that Go is object oriented in the sense that it allows types and methods, plus the style feels like object oriented java with strict interface inheritance. The "object" in Go is just a struct (like C). Methods can be designed for primitive types such as int. It is an imperiative language, meaning that it uses statements to describe the state of the program, in essence describing how your program operates. Other imperative languages FORTRAN, ALGOL, Pascal, BASIC, Java, C, Python, Javascript, Ruby, etc. Go has loops, statements, selections, etc. There are many things that Go won't do, for a variety of reasons that Go designers (aka people much smarter than us), have decided on. These are: "
    No ternary testing operation
    No generic types
    No exceptions
    No assertations
    No implements for interface
    No algebraic types
    No pointer arithmetic
    No semicolons and no opening brace on the next line
    No implicit numeric conversions
    No untagged unions, as in C
    No overloading of methods and operators
    No type inheritance"
    
    Go: 
    x := 0
    s:= "Hello, World!"
    No need to specify the types of variables, or use semicolons (can use semicolon, but it's implicit at the end of a line)
    Go can return multiple values!
    Go convention for error return: result, err
    Go uses range expression to iterate over arrays, strings, maps, channels (concurrency).

    Others (C): 
    int x = 0;
    const char* s = "Hello, World!";
    Usually only return one value.
    </p>  
    <p>
    Go has several built-in types: numeric (byte, int64, float32, etc.), boolean, and string. Character strings are immutable, operators and keywords concatenate, and compare. 
    Define custom "objects" or things of differing Type with struct.
    Can have an array of custom Type by specifying explicit length. Each array of differing length is technically a different type.
    [n]T
    Arrays can also be dynamic, in Go this is referred to as a slice, []T
    Pointers for type denoted: *T. NO POINTER ARITHMETIC!!! Memory Safety!!!
    Maps are a little weird, and the type map[K]V is the type of hash tables mapping type-K keys to type-V values. Hash tables are built into the language. Basically there is a channel T that allows sending values of type T between concurrent Go processes.
    The type keyword can be used to define a new named type, this obviously needs to be a distinct name. Conversion between types is allowed. For example assigning a named type to an integer value. Why would we ever do this? You ask. Well think of iPv4 addressing. You would need to make a named type iPv4
    type iPv4
    Since we know that these addresses are 32 unsigned integers we can do
    type iPv4 uint32
    Now we have a named type iPv4 which are all defined to be unsigned 32 bit integers. Pretty sweet, huh?
    </p>
    <p> 
    Function types are indicated by the func keyword; they take zero or more parameters and return zero or more values, all of which are typed
    func (numberA int64) isNumber1?/() bool {
    return numberA == 1
    }
    </p>
    <p>
    Go is very similar to Java with its inheritance. You design interfaces for your objects and explicitly typed values that are of the interface type inherit its characteristics.
    Go also has something similar to the superclass Object with the empty interface interface{}

    import "math"

    type Shape interface {
    Area() float64
    }

    type Square struct { // Note: no "implements" declaration
        side float64
    }

    func (sq Square) Area() float64 { return sq.side * sq.side }

    type Circle struct { // No "implements" declaration here either
        radius float64
    }

    func (c Circle) Area() float64 { return math.Pi * math.Pow(c.radius, 2) }
    </p>
    <p> 
    Can access other packages or libraries from GitHub or wherever, with the go get command by specifying the full path name
    go get github.com/user_name/package_name
    </p>
    <p>
    Go also supports parallel and asynchronous computing. This is done using goroutines which are a type process, uses channels to send messages between goroutines. Pretty technical, but we felt like you should know this exists! In fact, a study done by Google comparing unfamiliar Users and expert Users, "found that that the non-expert tended to write divide-and-conquer algorithms with one go statement per recursion, while the expert wrote distribute-work-synchronize programs using one goroutine per processor. The expert's programs were usually faster, but also longer."
    So this idea of paralellism can be implemented by non-experts and experts alike!
    </p>

</body>

</html>
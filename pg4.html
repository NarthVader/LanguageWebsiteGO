<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8">
    <title>Go Programming Language Website</title>
</head>

<body>
    <header id="main">
        <h1 id="banner">Go, GoLang</h1>
        <h2 id="banner">Description and History</h2>
    </header>
    <nav>
        <ul id="nav">
            <li id="navItem"><a id="navLink" href="index.html">Description and History</a></li>
            <li id="navItem"><a id="navLink" href="pg1.html">Links</a></li>
            <li id="navItem"><a id="navLink" href="pg2.html">Translators and Installation</a></li>
            <li id="navItem"><a id="navLink" href="pg3.html">Simple Examples</a></li>
            <li id="navItem"><a id="navLink" href="pg4.html">Complex Examples</a></li>
            <li id="navItem"><a id="navLink" href="pg5.html">Language Comparison</a></li>
        </ul>
    </nav>
    <p>  package main<br><br>

<br>//import multiple libraries/packages
<br><br>import (
<br>    "fmt"
<br>)<br>
<br>
<br>//takes an array(slice) of integers and prints all values
<br>func printSlice(s []int) {
<br>//len and cap are built in functions in GO. very C style print function
    <br>fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}<br>
<br>
//finds all multiples of 3 and 5 for a given number
<br>func findMult(value int) []int {
    <br>//example of a "dynamic" array hack, just don't initialize with size
    <br>//we'll use append to make the slice behave dynamic
    <br>var m []int
    <br>//iterator value (like C)
    <br>i := 0
<br>
    <br>//simpler for loop format
    <br>for i <= value {
    <br>    // can also use if math.Mod(i, 3) || math.Mod(i,5)
    <br>    if i%3 == 0 || i%5 == 0 {
            <br>//append the mult array with the multiple, append is also a built in
            <br>//just a note, this is very inefficient, but i thought it was a good demonstration of using arrays and built in functions
            <br>m = append(m, i)
            <br>//debug function that prints the array/slice given
            <br>printSlice(m)
       <br> }
    <br>}
    <br>//returns array of multiples
    <br>return m
<br>}
<br><br>
<br>func sum(x[] int) int {    
    <br>//static variable, static scope
    <br>total := 0
    <br>for _, valuex := range x {
       <br> total += valuex
    <br>}
    <br>return total
<br>}

<br>func main() {
    <br>//array of integers to find multiples on
    <br>num := 30
    <br>//somewhat functional. set the value of a new array of ints to that of the return from findMult()
    <br>var mult []int := findMult(num)
    <br>//fmt print the integer returned by feeding the array/slice we just made to a sum function
    <br>fmt.Println(sum(mult))
<br>}
    </p> 

<p>
package main
<br>
<br>import "fmt"
<br>import "math/rand"
<br><br>
<br>func main() {
    <br>fmt.Print("How many dice? (1-5):")
    <br>var numDice int
    <br>fmt.Scanln(&numDice)
    
   <br> fmt.Print("How many rolls? (1-100):")
    <br>var numRolls int
    <br>fmt.Scanln(&numRolls)
    
    
  <br>  rollThoseDice(numDice, numRolls)
<br>}

<br>func rollThoseDice(dice int, rolls int){
  <br>
<br>  var count int
  <br>count = 1
 <br> 
  <br>var origDice int
<br>  origDice = dice
  
  <br>var score int
  <br>score = 0
  <br>
  <br>for count <= rolls {
      <br> 
        <br>fmt.Print("Roll #")
        <br>fmt.Print(count)
        <br>fmt.Print(": ")
        <br>
        <br>for dice > 0 {
            <br>  
              <br>var tempRoll int
              <br>tempRoll = rand.Intn(6)+1
              <br>score += tempRoll
              <br>fmt.Print(tempRoll)
              <br>if dice > 1 {
                <br>fmt.Print(",")
              <br>}
              <br>dice--
       <br> }
        <br>
      <br>dice = origDice
      <br>fmt.Print("\n")
      <br>count++
 <br> }
  <br>
  <br>fmt.Print("Score: ")
  <br>fmt.Print(score)
  <br>fmt.Print("\n")
 <br> 
 <br> fmt.Print("Average Roll: ")
  <br>fmt.Print(float64(score)/float64(rolls))
  <br>fmt.Print("\n")
  <br>
<br>}
</p>

<p>
<br>package main
<br>import "fmt"
<br>import "math/rand"
<br>import "time"
<br><br><br>

<br>/*
<br><br>
<br>import "bufio"
<br>import "os"
<br>import "strconv"
<br><br>
<br>Card Dealer (Soon to be black jack, I hope...)
<br><br>
<br>Author: Garett Skaar
<br><br>
<br>Go LW1 program CS-354
<br><br>
<br>*/
<br><br>
<br>//Main will build a deck of cards, shuffle the cards and ask for a number
<br>//of cards to be dealt.
<br><br>func main() {
<br>
    <br>//Build a new deck, unshuffled...
    <br>deck := buildDeck()
    <br>//Shuffle deck...
    <br>shuffleDeck(deck)
    <br>//prompt user
    <br>fmt.Println("Deal how many cards?")
    <br>var userInput int
    <br>//scan standard input and check for errors
    <br>_, err := fmt.Scanf("%d", &userInput)
    <br>if err != nil {
    <br>        fmt.Println(err)
   <br> }
    <br>//display the desired amount of cards
    <br>Deal(deck, userInput)
   <br><br> 
    <br>/*
    <br>needs implemented for black jack
    <br>
    <br>if strings.Contains(userInput, "y"){
     <br>   fmt.Println()
     <br>   startGame(deck)
    <br>} else if strings.Contains(userInput, "n"){
      <br>  fmt.Println("Maybe next time!")
    <br>} else{
        <br>fmt.Println("Maybe next time!")
    <br>}
    <br>*/
 <br>   
<br>}
<br>//Deals the specified number of cards by user
<br>func Deal(d Deck, n int) {
   <br> for i := 0; i < n; i++ {
       <br> fmt.Println(d[i].value,"of",d[i].suit)
    <br>}
<br>}
<br>//needs work
<br>func startGame(deck Deck) {
<br>
<br>    dealer := []Card{}
<br>    player := []Card{}
<br>    //var dealerVal int = 0
<br>    //var playerVal int = 0
<br>    
<br>    //bust bool := false
<br>    fmt.Println("Dealing cards...")
<br>    for i :=0; i < len(deck) - 1;i++ {
<br>        dealer = append(dealer, deck[i])
<br>        player = append(player, deck[i+1])
<br>    }
<br>}
<br>
<br>//struct type holds suit type and value (Face, Ace, or Number)
<br>type Card struct {
<br>    value string
<br>    suit string
<br>}
<br>
<br>//Array of Card structs
<br>type Deck []Card
<br>
<br>
<br>
<br>//Builds and returns a new Card array
<br>func buildDeck() (deck Deck) {
<br>
<br>    //all valid values of a card
<br>    values := []string{"Two", "Three", "Four", "Five", "Six", "Seven",
<br>            "Eight", "Nine", "Ten", "Jack", "Queen", "King", "Ace"}
<br>            
<br>    //all valid suits   
<br>    suits := []string{"Hearts", "Diamonds", "Clubs", "Spades"}
<br>    <br>
    // Loop over each value and suit appending to the deck
<br>    for i := 0; i < len(values); i++ {
    <br>    for n := 0; n < len(suits); n++ {
        <br>    card := Card{
            <br>    value: values[i],
                <br>suit: suits[n],
            <br>}
            <br>deck = append(deck, card)
        <br>}
    <br>}
    <br>return deck     
     <br>   
<br>}
<br>//Returns a shuffled Deck of cards
<br>func shuffleDeck(deck Deck) Deck {
<br>
    <br>//new seed based on current time
    <br>rand.Seed(time.Now().UnixNano())
   <br> 
    <br>//Loops through deck, creates random int within deck size and current index, and
    <br>//swaps card postions if the index and random int are different.
   <br> 
    <br>for i := 1; i < len(deck); i++ {
    <br>    
    <br>    random := rand.Intn(i + 1)
     <br>   //swap the cards
        <br>if i != random {
           <br> deck[random], deck[i] = deck[i], deck[random]
        <br>}
    <br>}
    <br>return deck
<br>}   
</body>

</html>